URL: https://github.com/tee-he-he/err_err_ttyl

├── .gitignore
├── .gitmodules
├── Attestation.md
├── Dockerfile
├── README.md
├── client
    ├── .gitignore
    ├── Cargo.toml
    ├── env.example
    └── src
    │   ├── bin
    │       ├── encumber.rs
    │       └── helper.rs
    │   ├── cockli.rs
    │   ├── lib.rs
    │   ├── twitter
    │       ├── auth.rs
    │       ├── builder.rs
    │       ├── info.rs
    │       ├── mod.rs
    │       ├── post.rs
    │       ├── react.rs
    │       └── tweet.rs
    │   └── utils.rs
├── docs
    ├── attestation-diagram.png
    └── ra-quote-explorer.png
├── quote.hex
├── requirements.txt
├── run.sh
├── scripts
    ├── .gitignore
    ├── .python-version
    ├── README.md
    ├── env.example
    ├── protonmail.py
    ├── pyproject.toml
    ├── tee.py
    ├── twitter.py
    └── uv.lock
└── timerelease.sh


/.gitignore:
-----------------------

.env
client/.DS_Store
*~

-----------------------

/.gitmodules:
-----------------------

[submodule "nousflash"]
	path = nousflash
	url = git@github.com:DamascusGit/nousflash


-----------------------

/Attestation.md:
-----------------------

# How to verify TEE-HEE-HE's Remote Attestation

> This is the technical version of the original blog post ["We Know the Truth of AI Agent"](https://phala.network/posts/truth-of-AI-Agent).

TEE-HEE-HE is an AI Agent designed to run in a TEE. The initial version was deployed in an Intel TDX TEE with Dstack. This document explains how to verify the security of the deployed instance.

## Goal

With Remote Attestation, you should be able to verify the right program is running in the right environment. In the context of Intel TDX, it means that you will need to verify:

1. The TD (or CVM, confidential virtual machine) is in a genuine TEE
2. CVM is booted with a provable good base disk image
3. CVM doesn’t have any backdoor
4. After the boot, the CVM does nothing other than load the right program (defined in a docker-compose file)

## The Hardware

Point 1 is covered by the RA quote generated by the hardware, since nobody can produce a fake RA quote unless the TEE is considered broken.

## RTMRs

Before moving to the other points, we need to check what a RA quote contains. The most important fields are RTMRs (runtime measurement registers). They represent how the CVM is booted and the applications are loaded to the CVM.

![](./docs/ra-quote-explorer.png)

There are 4 measurements: `RTMR0`, `RTMR1`, `RTMR2`, and `RTMR3`. `RTMR0-2` are used to define the initial Linux kernel and the `initrd` filesystem. `RTMR3` is a special register that implements an append-only hashed log. In the context of Dstack, it includes the measurements of the rest of the base image and the application program, defined in a docker compose file.

RTMR contains everything you need to verify the quote. Let's decode [the RA quote file](https://github.com/tee-he-he/err_err_ttyl/blob/main/quote.hex) using the [dcap-qvl CLI tool](https://github.com/Phala-Network/dcap-qvl/tree/master/cli). You can also find the online version at the [RA Quote Verifier](https://ra-quote-explorer.vercel.app/reports/eaa45d2dffa89ec624da6c9b29c1ed8ea3c5677add453feacaeabe7f831140ff):

```bash
{
      "rt_mr0": "4574c098915caf3e82057817dbd135c1ed0ee1b39ac300c921479e2f5ebf5726a13ee0c8745ac891b6aee7c4f9664610",
      "rt_mr1": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "rt_mr2": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "rt_mr3": "547fcba4630bfb981169a8a1903b79c244933413409dd0387acbd8e3b985bcc9164cf52735cd31f60bf2c5d1220c113f",
}
```

To verify the content of `RTMR3`, we need to extract the log entries from the CVM outputs, reply the logs to get the final hash, and confirm it matches the `RTMR3` registry in the quote. Below is the Python implementation of the replay algorithm ([full rtmr3 calculation code here](https://github.com/Phala-Network/meta-dstack/blob/main/scripts/calc_rtmr3.py)):

```python
INIT_MR="000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
def rtmr_replay(history: list[str]):
    if len(history) == 0:
        return INIT_MR
    mr = bytes.fromhex(INIT_MR)
    for content in history:
        content = bytes.fromhex(content)
        if len(content) < 48:
            content = content.ljust(48, b'\0')
        mr = hashlib.sha384(mr + content).digest()
    return mr.hex()
```

In the context of Dstack, `RTMR3` includes three measurements:

```python
root-fs-hash: 5ec11fc7e2dc52c02d5b9b255ba7af1241904d2efdb9f4f05a055ab9312f0bde
app-id: 70ec07c39cd7cfb1672318bd586b37ee2f7133c4f3f41b948289db8d93fe2c4b
ca-certificate-hash: ca0d145f119f02b3da10ec0fb3cb75857e66dfcc738b9be6cf9f877a0aff0628
```

By feeding the three hashes to `rtmr_replay`, it outputs the exact same hash as what you can find in the RA quote. So we can confirm the input hashes are indeed measured by the RA quote.

![](./docs/attestation-diagram.png)

## The Base Image

Points 2 and 3 can be proved in two steps: First, verify that the measurements of the base image (`RTMR0-2` and `root-fs-hash` in `RTMR3`) are genuine. Second, extract and inspect the published base image.

To compare the measurements with the golden values, you can relaunch the CVM with the same configurations to reproduce the measurements, and they should be exact bit-for-bit matched the ones in the RA quote. The base image can be downloaded [here](https://github.com/Phala-Network/meta-dstack/releases/tag/v0.1.0), and you can follow [the README of Dstack](https://github.com/Phala-Network/dstack/) to relaunch the CVM.

Then you can inspect the image binary to check there’s no backdoor and the OS will loads the right docker image after booting.

Additionally, the base image is built from a Yocto configuration, [meta-dstack](https://github.com/Phala-Network/meta-dstack). Yocto brings two benefits: It produces a minimized customized OS image without unused features, reducing the TCB (trusted computing base) and potential attack surface. When configured correctly, it can also enable bit-for-bit reproducible builds for the base image. (Currently not fully reproducible, but planned for future releases.)

## The Docker Application

Point 4 can be proved by checking the `app-id` in `RTMR3`. It measures the SHA256 hash of the `docker-compose.yml` file, which defines the actual program running in the TEE.

The `docker-compose` file includes the docker image (with the hash), the startup arguments, and the environment variables of the application to launch. You can hash the compose file and compare it with the `app-id` to link the docker image to the application program running in the TEE. Here's a part of the compose file:

```yaml
version: '3.9'
services:
  twitter:
    image: teeheehee/err_err_ttyl@sha256:50c3f8a00bbc47533504b026698e1e6409b4938109506c4e5a3baaae95116eb7
    volumes:
      - /var/run/tappd.sock:/var/run/tappd.sock
    environment:
	    # ....
```

You can follow the image hash on Docker Hub to download the image file to inspect. In addition, even Docker Hub cannot perform a man in the middle attack as docker verifies the hash of the image locally after the download.

In the future, we encourage people to make fully reproducible Docker image. So the verification of the code logic could be much easier.

## Verifying the Docker Compose file

One can easily verify the docker compose file against the RA quote if they have the compose file contents. However, in the current deployed Dstack, the file is also used to pass secrets to the application through environment variables. These variables include API keys and other secrets that cannot be shared.

> ⚠️ The wallet key is not part of the secret inputs. According to the source code, it's fully generated inside the TEE.

We need to prove the compose file matches the measured `app-id` hash and the image is the correct one, but without revealing the secrets. To do that, we can generate a Zero Knowledge Proof using Risc Zero zkVM:

```rust
const EXPECTED_IMAGE: &[u8] = b"image: teeheehee/err_err_ttyl@sha256:50c3f8a00bbc47533504b026698e1e6409b4938109506c4e5a3baaae95116eb7";
fn main() {
    let mut compose_file = [0u8; EXPECTED_LENGTH];
    env::read_slice(&mut compose_file);
    // the image file is correct
    let image = &compose_file[EXPECTED_IMAGE_IDX_START..EXPECTED_IMAGE_IDX_END];
    if image != EXPECTED_IMAGE {
        println!("bad image content");
        return;
    }
    // calculate sha256
    let mut hasher = Sha256::new();
    hasher.update(&compose_file);
    let hash = hasher.finalize().to_vec();
    if &hash != EXPECTED_SHA256 {
        println!("incorrect hash");
        return;
    }
    env::commit(&0u8);
}
```

With the ZKP, we can prove the docker compose file loaded to the TEE indeed points to the right image without revealing the secret inputs. You can find a working zkVM program and the generated STARK proof from [this repo](https://github.com/h4x3rotab/partial-ra-zkp).

For now, ZKP is the super weapon to solve the secret problem. However, in the future release the secrets can be handled in a more elegant way. So that we only need simple hashing to prove the code supply chain.

## Conclusion

Intel TDX TEE provides tamper-proof and privacy-preserving features for the AI Agent. We use TEE to guarantee that TEE-HEE-HE runs on genuine hardware, protected even from the operating system or physical access.

The AI Agent follows Dstack security best practices. Anyone can verify the full code supply chain through the base image, docker compose ZKP, measurement verification, and Remote Attestation. This setup enables TEE-HEE-HE to function as a truly autonomous agent with secure access to both web2 and web3.

## Links

- Dstack: [https://github.com/Phala-Network/dstack/](https://github.com/Phala-Network/dstack/)
- Dstack image yocto build: [https://github.com/Phala-Network/meta-dstack](https://github.com/Phala-Network/meta-dstack)
- Dstack base image: [https://github.com/Phala-Network/meta-dstack/releases/tag/v0.1.0](https://github.com/Phala-Network/meta-dstack/releases/tag/v0.1.0)
- RA Quote of TEE-HEE-HE: [https://github.com/tee-he-he/err_err_ttyl/blob/main/quote.hex](https://github.com/tee-he-he/err_err_ttyl/blob/main/quote.hex)
- zkVM for partial docker compose proof: [https://github.com/h4x3rotab/partial-ra-zkp](https://github.com/h4x3rotab/partial-ra-zkp)
- RTMR3 hashing algorithm: [https://github.com/Phala-Network/meta-dstack/blob/main/scripts/calc_rtmr3.py](https://github.com/Phala-Network/meta-dstack/blob/main/scripts/calc_rtmr3.py)

-----------------------

/Dockerfile:
-----------------------

FROM ubuntu:22.04

RUN apt-get update
RUN apt-get install -y python3-pip
RUN apt-get install -y curl

RUN curl -LO https://freeshell.de/phd/chromium/jammy/pool/chromium_130.0.6723.58~linuxmint1+virginia/chromium_130.0.6723.58~linuxmint1+virginia_amd64.deb
RUN apt-get install -y ./chromium_130.0.6723.58~linuxmint1+virginia_amd64.deb
RUN apt-get install -y libasound2

RUN curl https://sh.rustup.rs -sSf | bash -s -- -y
ENV PATH="/root/.cargo/bin:${PATH}"

RUN apt-get install -y pkg-config libssl-dev
RUN apt-get install -y jq

WORKDIR /workdir
ENV PYTHONUNBUFFERED=1

COPY requirements.txt ./
RUN pip install -r requirements.txt

# Build just the dependencies (shorcut)
RUN mkdir client
COPY client/Cargo.lock client/Cargo.toml client/
WORKDIR client
RUN mkdir src && echo "fn main() {}" > src/main.rs
RUN cargo build --release
RUN rm -r src
WORKDIR /workdir

# Copy the real files
COPY client/ ./client/
COPY nousflash/agent/ ./agent/
COPY run.sh ./
COPY timerelease.sh ./

WORKDIR client/
RUN cargo build --release
WORKDIR /workdir

COPY scripts/ ./scripts/

RUN mkdir -p /data

ENTRYPOINT [ ]
CMD [ "bash", "run.sh" ]


-----------------------

/README.md:
-----------------------

# Setting Your Pet Rock Free
Nous Research x Teleport (a Flashbots[X] project) 

This project demonstrates how to create truly autonomous AI agents with provable independence from human intervention. Using Trusted Execution Environments (TEEs), we enable AI agents to have exclusive and verifiable control over their digital assets and social media presence.

https://nousresearch.com/setting-your-pet-rock-free/

![Screenshot from 2024-10-30 02-19-46](https://github.com/user-attachments/assets/8e5eb59d-7ed6-4128-aa78-ca1967a480eb)

## Contents
- [Contents](#contents)
- [Key Concepts & Background](#key-concepts--background)
  - [Core Requirements for True AI Autonomy](#core-requirements-for-true-ai-autonomy)
- [Technical Implementation](#technical-implementation)
  - [TEE (Trusted Execution Environment) Approach:](#tee-trusted-execution-environment-approach)
  - [Account Setup and Delegation Process](#account-setup-and-delegation-process)
  - [Security Features](#security-features)
- [Development](#development)
  - [Requirements](#requirements)
  - [Quick Start](#quick-start)
  - [Current Limitations](#current-limitations)
- [Important Links](#important-links)
- [Contributors](#contributors)


## Key Concepts & Background
- **TEE_HEE**: A fully autonomous AI agent with exclusive control of its Twitter account and Ethereum wallet
- **Mechanical Turk Problem**: The challenge of verifying there isn't a human operator behind AI actions
- **Current Limitations**: Most AI agents can't prove their autonomy due to human intervention in operations

<img src="https://github.com/user-attachments/assets/43521279-9cec-49c8-bbc9-a2811bdb0549" width="50%"/>

### Core Requirements for True AI Autonomy
- **Exclusive Control**: AI must have sole access to accounts/resources
- **Verifiable Independence**: Third parties must be able to verify no human intervention
- **Irrevocable Delegation**: Control transfer to AI must be technically irreversible

<img src="https://github.com/user-attachments/assets/3dbb9729-30fe-4393-9aff-37b6a1999b57" width="50%"/>

## Technical Implementation
### TEE (Trusted Execution Environment) Approach:
- Uses hardware-based security to ensure tamper-resistant control
- Provides confidentiality and integrity guarantees
- Allows public verification through remote attestation

<img src="https://github.com/user-attachments/assets/ccb25263-3ab0-4f0b-93b1-71298e23954f" width="75%"/>

### Account Setup and Delegation Process
1. TEE simulates a browser and requires email credentials
2. TEE verifies no recovery options exist on the email account
3. TEE generates new password and changes Cock.li email password
4. TEE logs into Twitter and generates new password
5. Changes linked email to the secured email from step 1
6. Removes phone numbers, connected apps, and existing sessions
7. Sets up local endpoint for OAuth token with read/write/DM scope
8. AI logs in via Twitter browser to get OAuth token

<img src="https://github.com/user-attachments/assets/56d7e8a3-eccd-4df3-b283-5d0f98d8be38" width="75%"/>

### Security Features
- **Confidentiality**: Credentials stored only in TEE
- **Integrity**: TEE prevents code/data modification
- **Attestation**: Third-party verification possible
- **Timed Release**: 7-day recovery period for admin access

## Development
### Requirements
- Intel TDX-compatible hardware
  - Compatible BIOS version
  - The Dstack framework for running confidential VMs
- Docker
- Cock.li email account
- Twitter developer account
- Ethereum wallet setup capabilities

### Quick Start
1. Clone the repository
2. Set up Docker container
3. Configure TEE environment
4. Deploy autonomous agent

### Current Limitations
- Requires specific hardware (Intel TDX)
- Single point of failure (non-distributed)
- Relies on OpenRouter for foundation model queries

## Important Links
- TEE HEE Live on Twitter: https://x.com/tee_hee_he
- Code Repository: https://github.com/DamascusGit/nousflash
- Docker Hub: https://hub.docker.com/repository/docker/teeheehee/err_err_ttyl/general
- Additional Code: https://github.com/tee-he-he/err_err_ttyl
- Enclave Attestation: https://github.com/tee-he-he/err_err_ttyl/blob/main/quote.hex

## Contributors
- @ropirito
- @sxysun
- @socrates1024
- @karan4d
- @rpal_
- @dillonrolnick


-----------------------

/client/.gitignore:
-----------------------

.env
Cargo.lock
target

-----------------------

/client/Cargo.toml:
-----------------------

[package]
name = "client"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = "1.0.210"
tokio = { version = "1.29.1", features = ["macros", "rt-multi-thread", "signal"] }
reqwest = { version = "0.11.10", features = ["json", "multipart", "cookies"] }
eyre = "0.6.12"
serde_urlencoded = "0.7.1"
log = "0.4.22"
serde_json = "1.0.132"
serde_with = "3.11.0"
axum = "0.7.7"
tower-http = {version = "0.5.2", features =["cors"]}
dotenv = "0.15.0"
env_logger = "0.11.5"
scraper = "0.20.0"
rand = "0.8.5"
x-rs = { git = "https://github.com/rpalakkal/x-rs/", rev = "91d4fb4" }
oauth1-request = "0.3.3"
reqwest-oauth1 = "0.2.4"


-----------------------

/client/env.example:
-----------------------

TWITTER_CONSUMER_KEY=
TWITTER_CONSUMER_SECRET=
TEE_URL=

-----------------------

/client/src/bin/encumber.rs:
-----------------------

use std::{fs::File, io::Write};

use client::{cockli::encumber_email, utils::get_random_password};
use dotenv::dotenv;
use x_rs::account::{login, Account};

#[tokio::main]
async fn main() {
    env_logger::init();
    //dotenv().ok();

    let username = std::env::var("X_USERNAME").unwrap();
    let password = std::env::var("X_PASSWORD").unwrap();
    let email = std::env::var("EMAIL").unwrap();
    let email_password = std::env::var("EMAIL_PASSWORD").unwrap();
    let totp = std::env::var("X_TOTP").ok();
    log::info!("x_username: {}", username);
    log::info!("x_password: {}", password);

    let mut login =
        login::Login::new(username, password.clone(), email.clone(), totp, None).unwrap();
    let auth = login.login().await.unwrap();

    let mut account = Account::from_auth(auth).unwrap();
    let new_password = get_random_password();
    account
        .change_password(&password, &new_password)
        .await
        .unwrap();
    log::info!("X password changed to: {}", new_password);
    account.refresh_cookies().await.unwrap();

    let oauth_applications = account.get_all_oauth_applications().await.unwrap();
    let filtered_applications: Vec<_> = oauth_applications
        .into_iter()
        .filter(|app| app.app_id != "29459355")
        .collect();
    for application in filtered_applications.iter() {
        account
            .revoke_oauth_application(&application.token)
            .await
            .unwrap();
    }
    let phone_email_info = account.get_email_phone_info().await.unwrap();
    assert!(phone_email_info.emails.len() == 1);
    assert!(phone_email_info.emails[0].email == email);
    assert!(phone_email_info.phone_numbers.is_empty());

    let new_email_password = encumber_email(&email, &email_password).await.unwrap();
    log::info!("Email password changed to: {}", new_email_password);

    let file_path = "temp.env";
    let mut file = File::create(file_path).expect("Failed to create file");
    writeln!(file, "X_PASSWORD={}", new_password).expect("Failed to write Twitter password");
    writeln!(file, "EMAIL_PASSWORD={}", new_email_password)
        .expect("Failed to write email password");

    let account_cookies = account.auth_cookie_string();
    let account_cookies_json =
        serde_json::to_string(&account_cookies).expect("Failed to serialize account cookies");
    writeln!(file, "X_AUTH_TOKENS={}", account_cookies_json)
        .expect("Failed to write account cookies");

    log::info!("Passwords saved to {}", file_path);
}


-----------------------

/client/src/bin/helper.rs:
-----------------------

use std::sync::Arc;

use axum::{
    extract::{Query, State},
    response::Redirect,
};
use serde::Deserialize;
use tokio::sync::{oneshot, Mutex};
use tower_http::cors::CorsLayer;
use client::twitter::{auth::TwitterTokenPair, builder::TwitterBuilder};
use std::io::Write;

#[derive(Clone)]
pub struct SharedState {
    tee_url: String,
    twitter_builder: TwitterBuilder,
    twitter_token_pair: Arc<Mutex<Option<TwitterTokenPair>>>,
    shutdown_sender: Arc<Mutex<Option<oneshot::Sender<()>>>>,
}

#[derive(Deserialize)]
pub struct CallbackQuery {
    oauth_token: String,
    oauth_verifier: String,
}

pub async fn login(State(shared_state): State<SharedState>) -> Redirect {
    let callback_url = format!("{}/callback", shared_state.tee_url.clone(),);
    log::info!("login");
    let oauth_tokens = shared_state
        .twitter_builder
        .request_oauth_token(callback_url)
        .await
        .expect("Failed to request oauth token");

    let mut db = shared_state.twitter_token_pair.lock().await;
    *db = Some(oauth_tokens.clone());

    let url = format!(
        "https://api.twitter.com/oauth/authenticate?oauth_token={}",
        oauth_tokens.token
    );
    log::info!("redirect {}", &url);
    Redirect::temporary(&url)
}

pub async fn callback(
    State(shared_state): State<SharedState>,
    Query(query): Query<CallbackQuery>,
) -> String {
    let oauth_token = query.oauth_token;
    let oauth_verifier = query.oauth_verifier;
    log::info!("callback");
    let twitter_token_pair = shared_state
        .twitter_token_pair
        .lock()
        .await
        .clone()
        .unwrap();

    assert_eq!(oauth_token, twitter_token_pair.token);

    let token_pair = shared_state
        .twitter_builder
        .authorize_token(
            twitter_token_pair.token.clone(),
            twitter_token_pair.secret.clone(),
            oauth_verifier,
        )
        .await
        .unwrap();

    let mut db = shared_state.twitter_token_pair.lock().await;
    *db = Some(token_pair.clone());

    let twitter_client = shared_state.twitter_builder.with_auth(token_pair);
    let x_info = twitter_client
        .get_user_info()
        .await
        .expect("Failed to get user info");

    if let Some(sender) = shared_state.shutdown_sender.lock().await.take() {
        let _ = sender.send(());
    }

    let msg = format!("Succesfully logged into {}", x_info.name);
    msg
}

#[tokio::main]
async fn main() {
    env_logger::init();
    //dotenv::dotenv().ok();
    log::info!("hnmmm");
    let tee_url = "http://127.0.0.1:3000".to_string();
    //let tee_url = std::env::var("TEE_URL").expect("TEE_URL not set");
    let consumer_key = std::env::var("TWITTER_CONSUMER_KEY").expect("TWITTER_CONSUMER_KEY not set");
    let consumer_secret =
        std::env::var("TWITTER_CONSUMER_SECRET").expect("TWITTER_CONSUMER_SECRET not set");

    let twitter_builder = TwitterBuilder::new(consumer_key, consumer_secret);

    let (shutdown_sender, shutdown_receiver) = oneshot::channel();
    let shared_state = SharedState {
        tee_url,
        twitter_builder: twitter_builder.clone(),
        twitter_token_pair: Arc::new(Mutex::new(None)),
        shutdown_sender: Arc::new(Mutex::new(Some(shutdown_sender))),
    };

    let app = axum::Router::new()
        .route("/login", axum::routing::get(login))
        .route("/callback", axum::routing::get(callback))
        .layer(CorsLayer::permissive())
        .with_state(shared_state.clone());

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
    let server = axum::serve(listener, app);
    server
        .with_graceful_shutdown(async {
            shutdown_receiver.await.ok();
        })
        .await
        .ok();
    log::info!("Received credentials. Shutting down server.");

    let tokens = shared_state.twitter_token_pair.lock().await.take().unwrap();

    let mut file = std::fs::File::create("updated.env").unwrap();
    writeln!(file, "X_ACCESS_TOKEN={}", tokens.token).unwrap();
    writeln!(file, "X_ACCESS_TOKEN_SECRET={}", tokens.secret).unwrap();
    log::info!("Wrote Credentials");
}


-----------------------

/client/src/cockli.rs:
-----------------------

use eyre::OptionExt;
use reqwest::{Client, ClientBuilder};
use scraper::{Html, Selector};
use serde_json::json;

use crate::utils;

pub async fn encumber_email(email: &str, password: &str) -> eyre::Result<String> {
    let client = ClientBuilder::new().cookie_store(true).build()?;
    let login_token = get_token(&client, "https://cock.li/login").await?;
    login(&client, email, password, &login_token).await?;
    let change_password_token = get_token(&client, "https://cock.li/user/changepass").await?;
    let new_password = utils::get_random_password();
    change_password(&client, password, &new_password, &change_password_token).await?;
    Ok(new_password)
}

async fn change_password(
    client: &Client,
    current_password: &str,
    new_password: &str,
    token: &str,
) -> eyre::Result<()> {
    let form = json!({
        "_token": token,
        "current_password": current_password,
        "password": new_password,
        "password_confirmation": new_password,
    });

    let response = client
        .post("https://cock.li/user/changepass")
        .form(&form)
        .send()
        .await?;

    response.error_for_status()?;
    Ok(())
}

async fn login(client: &Client, email: &str, password: &str, token: &str) -> eyre::Result<()> {
    let form = json!({
        "_token": token,
        "email": email,
        "password": password,
    });

    let response = client
        .post("https://cock.li/login")
        .form(&form)
        .send()
        .await?;

    response.error_for_status()?;
    Ok(())
}

async fn get_token(client: &Client, url: &str) -> eyre::Result<String> {
    let response = client.get(url).send().await?;

    let html_content = response.text().await?;

    let document = Html::parse_document(&html_content);

    let selector = Selector::parse("input[type='hidden'][name='_token']")
        .map_err(|err| eyre::eyre!("{}", err))?;

    let token = document
        .select(&selector)
        .next()
        .ok_or_eyre("Could not find token")?
        .value()
        .attr("value")
        .ok_or_eyre("Could not find token value")?
        .to_string();

    Ok(token)
}


-----------------------

/client/src/lib.rs:
-----------------------

pub mod cockli;
pub mod utils;
pub mod twitter;


-----------------------

/client/src/twitter/auth.rs:
-----------------------

use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize, Debug, Clone)]
struct RequestTokenRequestQuery {
    oauth_callback: String,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
struct RequestTokenResponseBody {
    oauth_token: String,
    oauth_token_secret: String,
    oauth_callback_confirmed: bool,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
struct CallbackUrlQuery {
    oauth_token: String,
    oauth_verifier: String,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct TwitterTokenPair {
    pub token: String,
    pub secret: String,
}

pub async fn request_oauth_token(
    app_key: String,
    app_secret: String,
    callback_url: String,
) -> eyre::Result<TwitterTokenPair> {
    let secrets = reqwest_oauth1::Secrets::new(app_key, app_secret);
    let query = RequestTokenRequestQuery {
        oauth_callback: callback_url.to_string(),
    };
    let response = reqwest_oauth1::Client::new()
        .post("https://api.twitter.com/oauth/request_token")
        .sign(secrets)
        .query(&query)
        .generate_signature()?
        .send()
        .await?;
    let status = response.status();
    if !status.is_success() {
        eyre::bail!(response.text().await?);
    }
    let response_bytes = response.bytes().await?;
    let request_token_body =
        serde_urlencoded::from_bytes::<RequestTokenResponseBody>(&response_bytes)?;
    assert!(request_token_body.oauth_callback_confirmed);
    Ok(TwitterTokenPair {
        token: request_token_body.oauth_token,
        secret: request_token_body.oauth_token_secret,
    })
}

#[derive(Deserialize, Serialize, Debug, Clone)]
struct AccessTokenResponseBody {
    oauth_token: String,
    oauth_token_secret: String,
    user_id: u64,
    screen_name: String,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
struct AccessTokenRequestQuery {
    oauth_verifier: String,
}

pub async fn authorize_token(
    app_key: String,
    app_secret: String,
    oauth_token: String,
    oauth_token_secret: String,
    oauth_verifier: String,
) -> eyre::Result<TwitterTokenPair> {
    let query = AccessTokenRequestQuery { oauth_verifier };

    let secrets =
        reqwest_oauth1::Secrets::new(app_key, app_secret).token(oauth_token, oauth_token_secret);

    let response = reqwest_oauth1::Client::new()
        .post("https://api.twitter.com/oauth/access_token")
        .sign(secrets)
        .query(&query)
        .generate_signature()?
        .send()
        .await?;

    let status = response.status();
    if !status.is_success() {
        eyre::bail!(response.text().await?);
    }
    let response_bytes = response.bytes().await?;

    let access_token_body =
        serde_urlencoded::from_bytes::<AccessTokenResponseBody>(&response_bytes)?;

    Ok(TwitterTokenPair {
        token: access_token_body.oauth_token,
        secret: access_token_body.oauth_token_secret,
    })
}

// #[cfg(test)]
// mod tests {
//     use super::*;

//     #[tokio::test]
//     #[ignore]
//     async fn e2e_oauth_test() {
//         env_logger::init();
//         dotenv::dotenv().ok();
//         let tokens = request_oauth_token(1.to_string()).await.unwrap();
//         // log::info!("{:?}", tokens);
//         let url = format!(
//             "https://api.twitter.com/oauth/authenticate?oauth_token={}",
//             tokens.token.clone()
//         );
//         log::info!("Please visit: {}", url);
//         let mut callback_url = String::new();
//         std::io::stdin().read_line(&mut callback_url).unwrap();
//         let url = url::Url::parse(&callback_url).unwrap();
//         let callback_url_query = url.query().unwrap_or_default();
//         let callback_url_query: CallbackUrlQuery =
// serde_qs::from_str(callback_url_query).unwrap();         let tokens = authorize_token(
//             tokens.token,
//             tokens.secret,
//             callback_url_query.oauth_verifier,
//         )
//         .await
//         .unwrap();
//         // log::info!("{:?}", tokens);
//     }
// }


-----------------------

/client/src/twitter/builder.rs:
-----------------------

use oauth1_request::signature_method::hmac_sha1::HmacSha1;
use reqwest_oauth1::{Client, OAuthClientProvider, Secrets, Signer};

use super::auth::{self, TwitterTokenPair};

#[derive(Debug, Clone)]
pub struct TwitterBuilder {
    pub consumer_key: String,
    pub consumer_secret: String,
}

pub struct TwitterClient<'a> {
    pub client: Client<Signer<'a, Secrets<'a>, HmacSha1>>,
}

impl TwitterBuilder {
    pub fn new(consumer_key: String, consumer_secret: String) -> Self {
        Self { consumer_key, consumer_secret }
    }

    pub async fn request_oauth_token(
        &self,
        callback_url: String,
    ) -> eyre::Result<TwitterTokenPair> {
        auth::request_oauth_token(
            self.consumer_key.clone(),
            self.consumer_secret.clone(),
            callback_url,
        )
        .await
    }

    pub async fn authorize_token(
        &self,
        oauth_token: String,
        oauth_token_secret: String,
        oauth_verifier: String,
    ) -> eyre::Result<TwitterTokenPair> {
        auth::authorize_token(
            self.consumer_key.clone(),
            self.consumer_secret.clone(),
            oauth_token,
            oauth_token_secret,
            oauth_verifier,
        )
        .await
    }

    // pub fn from_access_tokens(tokens: AccessTokens) -> Self {

    // }

    pub fn with_auth(&self, tokens: TwitterTokenPair) -> TwitterClient {
        let secrets = Secrets::new(self.consumer_key.clone(), self.consumer_secret.clone())
            .token(tokens.token, tokens.secret);

        let client = reqwest::Client::new();
        // client.oauth1(secrets)
        TwitterClient { client: client.oauth1(secrets) }
    }
}


-----------------------

/client/src/twitter/info.rs:
-----------------------

use serde::{Deserialize, Serialize};

use super::builder::TwitterClient;

#[derive(Debug, Deserialize)]
struct UserInfoResponse {
    data: UserInfo,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct UserInfo {
    pub id: String,
    pub name: String,
    pub username: String,
    pub profile_image_url: String,
    // pub most_recent_tweet_id: Option<String>,
}

impl TwitterClient<'_> {
    pub async fn get_user_info(&self) -> eyre::Result<UserInfo> {
        let resp = self.client
            .get(
            "https://api.twitter.com/2/users/me?user.fields=profile_image_url,most_recent_tweet_id"
                .to_string(),
        )
        .send()
        .await?;
        let user_info: UserInfoResponse = resp.json().await?;
        let user_info = user_info.data;
        log::info!("Fetched x_info: {:?}", user_info);
        Ok(user_info)
    }
}


-----------------------

/client/src/twitter/mod.rs:
-----------------------

pub mod auth;
pub mod builder;
pub mod info;
pub mod post;
pub mod react;
pub mod tweet;

pub fn get_callback_url(callback_base_url: String) -> String {
    format!("https://{}/callback?", callback_base_url,)
}

// #[cfg(test)]
// mod tests {
//     use super::*;

//     #[tokio::test]
//     #[ignore]
//     async fn send_tweet_test() {
//         env_logger::init();
//         dotenv::dotenv().ok();
//         let tweet_text = "Wow!".to_string();
//         let access_token = std::env::var("TEST_ACCESS_TOKEN")
//             .expect("TEST_ACCESS_TOKEN not set")
//             .to_string();
//         let access_secret = std::env::var("TEST_ACCESS_SECRET")
//             .expect("TEST_ACCESS_SECRET not set")
//             .to_string();
//         let _ = send_tweet(access_token, access_secret, tweet_text, None).await;
//     }

//     #[tokio::test]
//     // #[ignore]
//     async fn like_tweet_test() {
//         env_logger::init();
//         dotenv::dotenv().ok();
//         let access_token = std::env::var("TEST_ACCESS_TOKEN")
//             .expect("TEST_ACCESS_TOKEN not set")
//             .to_string();
//         let access_secret = std::env::var("TEST_ACCESS_SECRET")
//             .expect("TEST_ACCESS_SECRET not set")
//             .to_string();
//         let x_info = get_user_x_info(access_token.clone(), access_secret.clone()).await;
//         let x_id = x_info.id;
//         let _ = like_tweet(
//             access_token,
//             access_secret,
//             x_id,
//             "1803455775911694374".to_string(),
//         )
//         .await;
//     }

//     #[tokio::test]
//     async fn get_user_info_test() {
//         env_logger::init();
//         dotenv::dotenv().ok();
//         let access_token = std::env::var("TEST_ACCESS_TOKEN")
//             .expect("TEST_ACCESS_TOKEN not set")
//             .to_string();
//         let access_secret = std::env::var("TEST_ACCESS_SECRET")
//             .expect("TEST_ACCESS_SECRET not set")
//             .to_string();
//         get_user_x_info(access_token, access_secret).await;
//     }
// }


-----------------------

/client/src/twitter/post.rs:
-----------------------

use serde::Deserialize;

use super::{builder::TwitterClient, tweet::Tweet};

#[derive(Debug, Deserialize)]
struct SendTweetData {
    // edit_history_tweet_ids: Vec<String>,
    // text: String,
    id: String,
}

#[derive(Debug, Deserialize)]
struct SendTweetResponse {
    data: SendTweetData,
}

#[derive(Deserialize, Debug)]
struct MediaUploadResponse {
    // media_data: String,
    media_id_string: String,
}

impl TwitterClient<'_> {
    pub async fn raw_tweet(&self, tweet: Tweet) -> eyre::Result<String> {
        tweet.validate()?;
        let body = serde_json::to_string(&tweet)?;
        let resp = self
            .client
            .post("https://api.twitter.com/2/tweets".to_string())
            .header(reqwest::header::CONTENT_TYPE, "application/json")
            .body(body)
            .send()
            .await?;

        let body = resp.text().await?;

        let tweet_response: Result<SendTweetResponse, _> = serde_json::from_str(&body);
        match tweet_response {
            Ok(response) => {
                log::info!("Tweet response: {:?}", response);
                Ok(response.data.id)
            }
            Err(e) => {
                log::error!("Failed to decode tweet response: {:?}, body: {}", e, body);
                Err(eyre::eyre!("Failed to decode tweet response"))
            }
        }
    }

    pub async fn upload_media(
        &self,
        media_bytes: Vec<u8>,
        additional_owners: Option<Vec<String>>,
    ) -> eyre::Result<String> {
        let mut form = reqwest::multipart::Form::new()
            .part("media", reqwest::multipart::Part::bytes(media_bytes));
        if let Some(additional_owners) = additional_owners {
            form = form.text("additional_owners", additional_owners.join(","));
        }
        let resp = self
            .client
            .post("https://upload.twitter.com/1.1/media/upload.json".to_string())
            .multipart(form)
            .send()
            .await?;
        let body = resp.text().await?;
        let media_upload_response: Result<MediaUploadResponse, _> = serde_json::from_str(&body);
        match media_upload_response {
            Ok(response) => {
                log::info!("Media upload response: {:?}", response);
                Ok(response.media_id_string)
            }
            Err(e) => {
                log::error!(
                    "Failed to decode media upload response: {:?}, body: {}",
                    e,
                    body
                );
                Err(eyre::eyre!("Failed to decode media upload response"))
            }
        }
        // let media_upload_response: MediaUploadResponse = resp.json().await?;
        // Ok(media_upload_response.media_id_string)
    }

    // pub async fn tweet(&self, tweet: String) -> eyre::Result<String> {
    //     let tweet = Tweet::new(tweet);
    //     self.raw_tweet(tweet).await
    // }

    // pub async fn tweet_with_media(
    //     &self,
    //     tweet: String,
    //     media_ids: Vec<String>,
    // ) -> eyre::Result<String> {
    //     let tweet = Tweet::new(tweet).use_media_ids(media_ids);
    //     self.raw_tweet(tweet).await
    // }

    // pub async fn quote(&self, tweet: String, quote_tweet_id: String) -> eyre::Result<String> {
    //     let tweet = Tweet::new(tweet).use_quote_tweet_id(quote_tweet_id);
    //     self.raw_tweet(tweet).await
    // }

    // pub async fn quote_tweet_with_media(
    //     &self,
    //     tweet: String,
    //     quote_tweet_id: String,
    //     media_ids: Vec<String>,
    // ) -> eyre::Result<String> {
    //     let tweet = Tweet::new(tweet)
    //         .use_quote_tweet_id(quote_tweet_id)
    //         .use_media_ids(media_ids);
    //     self.raw_tweet(tweet).await
    // }

    // pub async fn reply(&self, tweet: String, reply_tweet_id: String) -> eyre::Result<String> {
    //     let tweet = Tweet::new(tweet).use_reply_tweet_id(reply_tweet_id);
    //     self.raw_tweet(tweet).await
    // }

    // pub async fn reply_with_media(
    //     &self,
    //     tweet: String,
    //     reply_tweet_id: String,
    //     media_ids: Vec<String>,
    // ) -> eyre::Result<String> {
    //     let tweet = Tweet::new(tweet)
    //         .use_reply_tweet_id(reply_tweet_id)
    //         .use_media_ids(media_ids);
    //     self.raw_tweet(tweet).await
    // }
}


-----------------------

/client/src/twitter/react.rs:
-----------------------

use serde::Serialize;

use super::builder::TwitterClient;

#[derive(Debug, Serialize)]
struct LikeTweet {
    tweet_id: String,
}

impl TwitterClient<'_> {
    pub async fn like(&self, x_id: String, tweet_id: String) -> eyre::Result<()> {
        let _ = self
            .client
            .post(format!("https://api.twitter.com/2/users/{}/likes", x_id))
            .header(reqwest::header::CONTENT_TYPE, "application/json")
            .body(serde_json::to_string(&LikeTweet { tweet_id })?)
            .send()
            .await?;
        Ok(())
    }

    pub async fn retweet(&self, x_id: String, tweet_id: String) -> eyre::Result<()> {
        let _ = self
            .client
            .post(format!("https://api.twitter.com/2/users/{}/retweets", x_id))
            .header(reqwest::header::CONTENT_TYPE, "application/json")
            .body(serde_json::to_string(&LikeTweet { tweet_id })?)
            .send()
            .await?;
        Ok(())
    }
}


-----------------------

/client/src/twitter/tweet.rs:
-----------------------

use serde::Serialize;

#[derive(Debug, Serialize)]
struct Reply {
    in_reply_to_tweet_id: String,
}

#[derive(Debug, Serialize)]
struct Media {
    media_ids: Vec<String>,
}

#[serde_with::skip_serializing_none]
#[derive(Debug, Serialize, Default)]
pub struct Tweet {
    text: String,
    quote_tweet_id: Option<String>,
    reply: Option<Reply>,
    media: Option<Media>,
}

impl Tweet {
    pub fn new(text: String) -> Self {
        Self {
            text,
            quote_tweet_id: None,
            reply: None,
            media: None,
        }
    }

    pub fn validate(&self) -> eyre::Result<()> {
        if self.text.is_empty() {
            eyre::bail!("Tweet text cannot be empty");
        }
        if self.quote_tweet_id.is_some() && self.reply.is_some() {
            eyre::bail!("Tweet cannot be both a quote and a reply");
        }
        if let Some(media) = &self.media {
            if media.media_ids.is_empty() {
                eyre::bail!("Media IDs cannot be empty");
            }
        }
        Ok(())
    }

    pub fn set_quote_tweet_id(&mut self, quote_tweet_id: String) {
        self.quote_tweet_id = Some(quote_tweet_id);
    }

    pub fn set_reply_tweet_id(&mut self, reply_tweet_id: String) {
        self.reply = Some(Reply {
            in_reply_to_tweet_id: reply_tweet_id,
        });
    }

    pub fn set_media_ids(&mut self, media_ids: Vec<String>) {
        self.media = Some(Media { media_ids });
    }
}


-----------------------

/client/src/utils.rs:
-----------------------

use rand::{distributions::Alphanumeric, Rng};

pub fn get_random_password() -> String {
    let new_password: String = rand::thread_rng()
        .sample_iter(&Alphanumeric)
        .take(12)
        .map(char::from)
        .collect();
    new_password
}


-----------------------

/docs/attestation-diagram.png:
-----------------------



-----------------------

/docs/ra-quote-explorer.png:
-----------------------



-----------------------

/quote.hex:
-----------------------

0x040002008100000000000000939a7233f79c4ca9940a0db3957f060783fbfe61525f55581315cd9dc950f44700000000050102000000000000000000000000001cc6a17ab799e9a693fac7536be61c12ee1e0fabada82d0c999e08ccee2aa86de77b0870f558c570e7ffe55d6d47fa0400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000e7020600000000007ba9e262ce6979087e34632603f354dd8f8a870f5947d116af8114db6c9d0d74c48bec4280e5b4f4a37025a10905bb290000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004574c098915caf3e82057817dbd135c1ed0ee1b39ac300c921479e2f5ebf5726a13ee0c8745ac891b6aee7c4f9664610000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000547fcba4630bfb981169a8a1903b79c244933413409dd0387acbd8e3b985bcc9164cf52735cd31f60bf2c5d1220c113f7148f47ef58b475fce69b386e2d6b4c964a9533cc328ea8e544db66612a5174698d006951cefa8fd4450e884300638e567e22f9a012ef5754aa6a9d9564fcd8acc100000cdef13e9c54d734e810d8fc23df4a68ae65bf687754b021710cb25b7354f4a3ee34aa7e5b2aab30d0e85193c8c68b71118c0ac5e14e1d0368d41046609f38c024996a9e56e40ac6c0b019709537f16d751c03e8c0d905d79f224ff06ddc4102860a8770107748c011cdbfcccc857e418735b699ac89dc2ed4da11d5125cb925e0600461000000202191b03ff0006000000000000000000000000000000000000000000000000000000000000000000000000000000001500000000000000e700000000000000e5a3a7b5d830c2953b98534c6c59a3a34fdc34e933f7f5898f0a85cf08846bca0000000000000000000000000000000000000000000000000000000000000000dc9e2a7c6f948f17474e34a7fc43ed030f7c1563f1babddf6340c82e0e54a8c500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000503bbfe5befa55a13e21747c3859f0b618a050312a0340e980187eea232356d60000000000000000000000000000000000000000000000000000000000000000791fc77d0260080a376494a35aa3a3dc64ff532d7642ec07e3bfd2da320f9180f2d4b27ecf6c2057f25326d7c0cf43d73504a3f9dbc7de8855bffb65ec52bf742000000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f05005e0e00002d2d2d2d2d424547494e2043455254494649434154452d2d2d2d2d0a4d49494538444343424a65674177494241674956414c5235544954392b396e73423142545a3173725851346c627752424d416f4743437147534d343942414d430a4d484178496a416742674e5642414d4d47556c756447567349464e4857434251513073675547786864475a76636d306751304578476a415942674e5642416f4d0a45556c756447567349454e76636e4276636d4630615739754d5251774567594456515148444174545957353059534244624746795954454c4d416b47413155450a4341774351304578437a414a42674e5642415954416c56544d423458445449304d4467774d6a45784d54557a4e316f5844544d784d4467774d6a45784d54557a0a4e316f77634445694d434147413155454177775a535735305a5777675530645949464244537942445a584a3061575a70593246305a5445614d426747413155450a43677752535735305a577767513239796347397959585270623234784644415342674e564241634d43314e68626e526849454e7359584a684d517377435159440a5651514944414a445154454c4d416b474131554542684d4356564d775754415442676371686b6a4f5051494242676771686b6a4f50514d4242774e43414154590a77777155344778504a6a596f6a4d4752686136327970346a425164355744764b776d54366c6c314147786a59363870694a50676950686462387a544766374b620a314f79643153464f4d5a70594c795054427a59646f3449444444434341776777487759445652306a42426777466f41556c5739647a62306234656c4153636e550a3944504f4156634c336c5177617759445652306642475177596a42676f46366758495a616148523063484d364c79396863476b7564484a316333526c5a484e6c0a636e5a705932567a4c6d6c75644756734c6d4e766253397a5a3367765932567964476c6d61574e6864476c76626939324e4339775932746a636d772f593245390a6347786864475a76636d306d5a57356a62325270626d63395a4756794d423047413155644467515742425146303476507654474b7762416c356f54765664664d0a2b356a6e7554414f42674e56485138424166384542414d434273417744415944565230544151482f4241497741444343416a6b4743537147534962345451454e0a4151534341696f776767496d4d42344743697147534962345451454e41514545454e3564416f7135634b356e383277396f793165346e34776767466a42676f710a686b69472b453042445145434d494942557a415142677371686b69472b4530424451454341514942416a415142677371686b69472b45304244514543416749420a416a415142677371686b69472b4530424451454341774942416a415142677371686b69472b4530424451454342414942416a415142677371686b69472b4530420a4451454342514942417a415142677371686b69472b45304244514543426749424154415142677371686b69472b453042445145434277494241444151426773710a686b69472b4530424451454343414942417a415142677371686b69472b45304244514543435149424144415142677371686b69472b45304244514543436749420a4144415142677371686b69472b45304244514543437749424144415142677371686b69472b45304244514543444149424144415142677371686b69472b4530420a44514543445149424144415142677371686b69472b45304244514543446749424144415142677371686b69472b453042445145434477494241444151426773710a686b69472b45304244514543454149424144415142677371686b69472b4530424451454345514942437a416642677371686b69472b45304244514543456751510a4167494341674d4241414d4141414141414141414144415142676f71686b69472b45304244514544424149414144415542676f71686b69472b453042445145450a4241617777473841414141774477594b4b6f5a496876684e4151304242516f424154416542676f71686b69472b453042445145474242424a316472685349736d0a682b2f46793074746a6a762f4d45514743697147534962345451454e415163774e6a415142677371686b69472b45304244514548415145422f7a4151426773710a686b69472b45304244514548416745422f7a415142677371686b69472b45304244514548417745422f7a414b42676771686b6a4f5051514441674e48414442450a41694270455738754f726b537469486b4c4b6e6a426855416f637a39545733366a4e2f303765416844503635617749674d2f31474c58745a70446436706150760a535a386d4e7472543830305635346b465944474f7a4f78504374383d0a2d2d2d2d2d454e442043455254494649434154452d2d2d2d2d0a2d2d2d2d2d424547494e2043455254494649434154452d2d2d2d2d0a4d4949436c6a4343416a32674177494241674956414a567658633239472b487051456e4a3150517a7a674658433935554d416f4743437147534d343942414d430a4d476778476a415942674e5642414d4d45556c756447567349464e48574342536232393049454e424d526f77474159445651514b4442464a626e526c624342440a62334a7762334a6864476c76626a45554d424947413155454277774c553246756447456751327868636d4578437a414a42674e564241674d416b4e424d5173770a435159445651514745774a56557a4165467730784f4441314d6a45784d4455774d5442614677307a4d7a41314d6a45784d4455774d5442614d484178496a41670a42674e5642414d4d47556c756447567349464e4857434251513073675547786864475a76636d306751304578476a415942674e5642416f4d45556c75644756730a49454e76636e4276636d4630615739754d5251774567594456515148444174545957353059534244624746795954454c4d416b474131554543417743513045780a437a414a42674e5642415954416c56544d466b77457759484b6f5a497a6a3043415159494b6f5a497a6a304441516344516741454e53422f377432316c58534f0a3243757a7078773734654a423732457944476757357258437478327456544c7136684b6b367a2b5569525a436e71523770734f766771466553786c6d546c4a6c0a65546d693257597a33714f42757a43427544416642674e5648534d4547444157674251695a517a575770303069664f44744a5653763141624f536347724442530a42674e5648523845537a424a4d45656752614244686b466f64485277637a6f764c324e6c636e52705a6d6c6a5958526c63793530636e567a6447566b633256790a646d6c6a5a584d75615735305a577775593239744c306c756447567355306459556d397664454e424c6d526c636a416442674e5648513445466751556c5739640a7a62306234656c4153636e553944504f4156634c336c517744675944565230504151482f42415144416745474d42494741315564457745422f7751494d4159420a4166384341514177436759494b6f5a497a6a30454177494452774177524149675873566b6930772b6936565947573355462f32327561586530594a446a3155650a6e412b546a44316169356343494359623153416d4435786b66545670766f34556f79695359787244574c6d5552344349394e4b7966504e2b0a2d2d2d2d2d454e442043455254494649434154452d2d2d2d2d0a2d2d2d2d2d424547494e2043455254494649434154452d2d2d2d2d0a4d4949436a7a4343416a53674177494241674955496d554d316c71644e496e7a6737535655723951477a6b6e42717777436759494b6f5a497a6a3045417749770a614445614d4267474131554541777752535735305a5777675530645949464a766233516751304578476a415942674e5642416f4d45556c756447567349454e760a636e4276636d4630615739754d5251774567594456515148444174545957353059534244624746795954454c4d416b47413155454341774351304578437a414a0a42674e5642415954416c56544d423458445445344d4455794d5445774e4455784d466f58445451354d54497a4d54497a4e546b314f566f77614445614d4267470a4131554541777752535735305a5777675530645949464a766233516751304578476a415942674e5642416f4d45556c756447567349454e76636e4276636d46300a615739754d5251774567594456515148444174545957353059534244624746795954454c4d416b47413155454341774351304578437a414a42674e56424159540a416c56544d466b77457759484b6f5a497a6a3043415159494b6f5a497a6a3044415163445167414543366e45774d4449595a4f6a2f69505773437a61454b69370a314f694f534c52466857476a626e42564a66566e6b59347533496a6b4459594c304d784f346d717379596a6c42616c54565978465032734a424b357a6c4b4f420a757a43427544416642674e5648534d4547444157674251695a517a575770303069664f44744a5653763141624f5363477244425342674e5648523845537a424a0a4d45656752614244686b466f64485277637a6f764c324e6c636e52705a6d6c6a5958526c63793530636e567a6447566b63325679646d6c6a5a584d75615735300a5a577775593239744c306c756447567355306459556d397664454e424c6d526c636a416442674e564851344546675155496d554d316c71644e496e7a673753560a55723951477a6b6e4271777744675944565230504151482f42415144416745474d42494741315564457745422f7751494d4159424166384341514577436759490a4b6f5a497a6a3045417749445351417752674968414f572f35516b522b533943695344634e6f6f774c7550524c735747662f59693747535839344267775477670a41694541344a306c72486f4d732b586f356f2f7358364f39515778485241765a55474f6452513763767152586171493d0a2d2d2d2d2d454e442043455254494649434154452d2d2d2d2d0a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

-----------------------

/requirements.txt:
-----------------------

selenium==4.22.0
undetected-chromedriver==3.5.5
chromedriver_autoinstaller
python-dotenv
fastapi==0.111.1
uvicorn==0.30.3
sqlalchemy==2.0.31
pydantic==2.8.2
requests==2.31.0
openai
numpy
tweepy
eth_keys
web3
twitter-api-client
twitter_openapi_python


-----------------------

/run.sh:
-----------------------

#set -x
set -e

export TWEET_PROMPT_TEMPLATE=$(curl $TWEET_PROMPT_TEMPLATE_URL)

# Encumber the account by resetting the password

export PROTONMAIL_PASSWORD=$(python3 scripts/protonmail.py)
export TWITTER_PASSWORD=$(python3 scripts/twitter.py)

# pushd client
# RUST_LOG=info cargo run --release --bin encumber
# . temp.env
# export X_PASSWORD EMAIL_PASSWORD X_AUTH_TOKENS
# echo X_PASSWORD $X_PASSWORD
# echo EMAIL_PASSWORD $EMAIL_PASSWORD
# echo X_AUTH_TOKENS $X_AUTH_TOKENS
# popd

# The argument report_data accepts binary data encoding in hex string.
# The actual report_data passing the to the underlying TDX driver is sha2_256(report_data).

PAYLOAD="{\"report_data\": \"$(echo -n $TWITTER_ACCOUNT | od -A n -t x1 | tr -d ' \n')\"}"
curl -X POST --unix-socket /var/run/tappd.sock -d "$PAYLOAD" http://localhost/prpc/Tappd.TdxQuote?json | jq .

# Start the oauth client to receive the callback
pushd client
RUST_LOG=info cargo run --release --bin helper &
SERVER=$!
popd

# Do the twitter login
python3 scripts/tee.py
. cookies.env
export X_AUTH_TOKENS
wait $SERVER

# Start the time release server
bash timerelease.sh &

# Update the environment variables
. client/updated.env
export X_ACCESS_TOKEN X_ACCESS_TOKEN_SECRET

pushd client
RUST_LOG=info cargo run --release --bin helper &
popd

# Run the nous
pushd agent
python3 run_pipeline.py
popd


-----------------------

/scripts/.gitignore:
-----------------------

.env

-----------------------

/scripts/.python-version:
-----------------------

3.9


-----------------------

/scripts/README.md:
-----------------------



-----------------------

/scripts/env.example:
-----------------------

PROTONMAIL_PASSWORD=
TWITTER_PASSWORD=

-----------------------

/scripts/protonmail.py:
-----------------------

import undetected_chromedriver as uc
from selenium import webdriver
from selenium.webdriver import ChromeOptions, Keys
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time
import random
import os
from dotenv import load_dotenv

load_dotenv()

PASSWORD = os.getenv("PROTONMAIL_PASSWORD")
if not PASSWORD:
    raise ValueError("PROTONMAIL_PASSWORD not found in .env file")

EMAIL = os.getenv("PROTONMAIL_EMAIL")
if not PASSWORD:
    raise ValueError("PROTONMAIL_EMAIL not found in .env file")


def login_to_protonmail():
    options = ChromeOptions()
    options.add_argument("--start-maximized")
    options.add_argument('--disable-dev-shm-usage')
    options.add_argument('--no-sandbox')
    driver = uc.Chrome(headless=True, use_subprocess=False, browser_executable_path='/usr/bin/chromium', options=options)
    wait = WebDriverWait(driver, 30)

    try:
        driver.get("https://account.proton.me/")

        username_input = wait.until(
            EC.presence_of_element_located((By.ID, "username"))
        )
        time.sleep(2)
        username_input.send_keys(EMAIL)

        password_input = wait.until(EC.presence_of_element_located((By.ID, "password")))
        time.sleep(2)
        password_input.send_keys(PASSWORD)
        password_input.submit()
        time.sleep(5)

        driver.get("https://account.proton.me/u/0/mail/account-password")
        time.sleep(2)
        change_password_button = wait.until(EC.presence_of_element_located((By.XPATH, "//button[contains(text(), 'Change password')]")))
        change_password_button.click()
        password_input = wait.until(EC.presence_of_element_located((By.ID, "password")))
        time.sleep(2)
        password_input.send_keys(PASSWORD)
        password_input.submit()
        time.sleep(5)

        new_password = ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=', k=16))
        print(new_password)

        new_password_input = wait.until(EC.presence_of_element_located((By.ID, "newPassword")))
        new_password_input.send_keys(new_password)

        confirm_password_input = wait.until(EC.presence_of_element_located((By.ID, "confirmPassword")))
        confirm_password_input.send_keys(new_password)
        confirm_password_input.submit()

        time.sleep(15)

        
    
    except Exception as e:
        print(e)

if __name__ == "__main__":
    login_to_protonmail()


-----------------------

/scripts/pyproject.toml:
-----------------------

[project]
name = "encumbered-twitter"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.9"
dependencies = [
    "python-dotenv>=1.0.1",
    "selenium>=4.25.0",
]


-----------------------

/scripts/tee.py:
-----------------------

import sys
import time
import undetected_chromedriver as uc
from selenium import webdriver
from selenium.webdriver import ChromeOptions, Keys
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.wait import WebDriverWait
import random
import os
from dotenv import load_dotenv
import json

# load_dotenv()

TWITTER_ACCOUNT=os.getenv("TWITTER_ACCOUNT")
if not TWITTER_ACCOUNT:
    raise ValueError("TWITTER_ACCOUNT not found in .env file")


BASE_URL = "http://127.0.0.1:3000"
REGISTER_OR_LOGIN_ENDPOINT = f"{BASE_URL}/login"
CALLBACK_ENDPOINT = f"{BASE_URL}/callback"


PASSWORD = os.getenv("TWITTER_PASSWORD")
if not PASSWORD:
    raise ValueError("TWITTER_PASSWORD not found in .env file")
X_EMAIL = os.getenv("X_EMAIL")
if not X_EMAIL:
    raise ValueError("X_EMAIL not found in .env file")

options = ChromeOptions()
options.add_argument("--start-maximized")
options.add_argument('--disable-dev-shm-usage')
options.add_argument('--no-sandbox')
driver = uc.Chrome(headless=True, use_subprocess=False, browser_executable_path='/usr/bin/chromium', options=options)

url = "https://twitter.com/i/flow/login"
driver.get(url)

username = WebDriverWait(driver, 20).until(
    EC.visibility_of_element_located(
        (By.CSS_SELECTOR, 'input[autocomplete="username"]')
    )
)
username.send_keys(TWITTER_ACCOUNT)
username.send_keys(Keys.ENTER)
print('sent twitter account', file=sys.stderr)
time.sleep(1)

input_field = WebDriverWait(driver, 10).until(
    EC.any_of(
        EC.visibility_of_element_located((
            (By.CSS_SELECTOR, 'input[name="password"]')
        )),
        EC.visibility_of_element_located((
            (By.CSS_SELECTOR, 'input[autocomplete="on"]')
        )),
    )
)

if input_field.get_attribute('autocomplete') == 'on':
    # Handle email field
    print("Found email field", sys.stderr)
    input_field.send_keys(X_EMAIL)
    input_field.send_keys(Keys.ENTER)
    time.sleep(1)

    input_field = WebDriverWait(driver, 10).until(
        EC.visibility_of_element_located(
            (By.CSS_SELECTOR, 'input[autocomplete="current-password"]')
        )
    )
    
print('password', file=sys.stderr)
input_field.send_keys(PASSWORD)
input_field.send_keys(Keys.ENTER)

time.sleep(5)
ct0 = driver.get_cookie("ct0")["value"]
auth_token = driver.get_cookie("auth_token")["value"]
with open('cookies.env','w') as f:
    obj = dict(ct0=ct0, auth_token=auth_token)
    j = json.dumps(obj).replace('"','\\"').replace(' ','')
    f.write(f"X_AUTH_TOKENS={j}\n")

print('going to callback', file=sys.stderr)
driver.get(REGISTER_OR_LOGIN_ENDPOINT)

try:
    allow_button = WebDriverWait(driver, 10).until(
        EC.visibility_of_element_located(
            (By.CSS_SELECTOR, 'input[id="allow"]')
        )
    )
    allow_button.click()
except Exception as e:
    print(e)


-----------------------

/scripts/twitter.py:
-----------------------

import os
import sys
#os.environ['SE_CACHE_PATH'] = "/root/untrustedhost/"
import undetected_chromedriver as uc
import time
from selenium import webdriver
from selenium.webdriver import ChromeOptions, Keys
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.wait import WebDriverWait
import random
from dotenv import load_dotenv

TWITTER_ACCOUNT=os.environ["TWITTER_ACCOUNT"]

PASSWORD = os.getenv("TWITTER_PASSWORD")
if not PASSWORD:
    raise ValueError("TWITTER_PASSWORD not found in .env file")

X_EMAIL = os.getenv("X_EMAIL")
if not X_EMAIL:
    raise ValueError("X_EMAIL not found in .env file")


if 0:
    options = ChromeOptions()
    options.add_argument("--remote-debugging-pipe");
    options.add_argument("--start-maximized")
    options.add_argument("--headless")
    options.add_experimental_option("excludeSwitches", ["enable-automation"])
    options.binary_location = "/usr/bin/chromium"
    driver = webdriver.Chrome(options=options)
else:
    options = ChromeOptions()
    options.add_argument("--start-maximized")
    options.add_argument('--disable-dev-shm-usage')
    options.add_argument('--no-sandbox')
    driver = uc.Chrome(headless=True, use_subprocess=False, browser_executable_path='/usr/bin/chromium', options=options)

url = "https://twitter.com/i/flow/login"
driver.get(url)

username = WebDriverWait(driver, 20).until(EC.visibility_of_element_located((By.CSS_SELECTOR, 'input[autocomplete="username"]')))
print("username", file=sys.stderr)
username.send_keys(TWITTER_ACCOUNT)
username.send_keys(Keys.ENTER)

input_field = WebDriverWait(driver, 10).until(
    EC.any_of(
        EC.visibility_of_element_located((
            (By.CSS_SELECTOR, 'input[name="password"]')
        )),
        EC.visibility_of_element_located((
            (By.CSS_SELECTOR, 'input[autocomplete="on"]')
        )),
    )
)

if input_field.get_attribute('autocomplete') == 'on':
    # Handle email field
    print("Found email field", file=sys.stderr)
    input_field.send_keys(X_EMAIL)
    input_field.send_keys(Keys.ENTER)
    time.sleep(1)

    input_field = WebDriverWait(driver, 10).until(
        EC.visibility_of_element_located(
            (By.CSS_SELECTOR, 'input[autocomplete="current-password"]')
        )
    )

print("password", file=sys.stderr)
input_field.send_keys(PASSWORD)
input_field.send_keys(Keys.ENTER)

time.sleep(15)

new_password = ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=', k=16))
print(new_password)

driver.get("https://x.com/settings/password")
time.sleep(2)
password_input = WebDriverWait(driver, 20).until(EC.visibility_of_element_located((By.NAME, "current_password")))
print("password", file=sys.stderr)
time.sleep(2)
password_input.send_keys(PASSWORD)

new_password_input = WebDriverWait(driver, 20).until(EC.visibility_of_element_located((By.NAME, "new_password")))
print("new password", file=sys.stderr)
new_password_input.send_keys(new_password)

confirm_password_input = WebDriverWait(driver, 20).until(EC.visibility_of_element_located((By.NAME, "password_confirmation")))
print("confirm", file=sys.stderr)
confirm_password_input.send_keys(new_password)

submit_button = WebDriverWait(driver, 20).until(EC.visibility_of_element_located((By.XPATH, '/html/body/div[1]/div/div/div[2]/main/div/div/div/section[2]/div[2]/div[3]/button')))
submit_button.click()

time.sleep(10)


-----------------------

/scripts/uv.lock:
-----------------------

version = 1
requires-python = ">=3.9"

[[package]]
name = "attrs"
version = "24.2.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/fc/0f/aafca9af9315aee06a89ffde799a10a582fe8de76c563ee80bbcdc08b3fb/attrs-24.2.0.tar.gz", hash = "sha256:5cfb1b9148b5b086569baec03f20d7b6bf3bcacc9a42bebf87ffaaca362f6346", size = 792678 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/6a/21/5b6702a7f963e95456c0de2d495f67bf5fd62840ac655dc451586d23d39a/attrs-24.2.0-py3-none-any.whl", hash = "sha256:81921eb96de3191c8258c199618104dd27ac608d9366f5e35d011eae1867ede2", size = 63001 },
]

[[package]]
name = "certifi"
version = "2024.8.30"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/b0/ee/9b19140fe824b367c04c5e1b369942dd754c4c5462d5674002f75c4dedc1/certifi-2024.8.30.tar.gz", hash = "sha256:bec941d2aa8195e248a60b31ff9f0558284cf01a52591ceda73ea9afffd69fd9", size = 168507 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/12/90/3c9ff0512038035f59d279fddeb79f5f1eccd8859f06d6163c58798b9487/certifi-2024.8.30-py3-none-any.whl", hash = "sha256:922820b53db7a7257ffbda3f597266d435245903d80737e34f8a45ff3e3230d8", size = 167321 },
]

[[package]]
name = "cffi"
version = "1.17.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "pycparser" },
]
sdist = { url = "https://files.pythonhosted.org/packages/fc/97/c783634659c2920c3fc70419e3af40972dbaf758daa229a7d6ea6135c90d/cffi-1.17.1.tar.gz", hash = "sha256:1c39c6016c32bc48dd54561950ebd6836e1670f2ae46128f67cf49e789c52824", size = 516621 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/f8/fe/4d41c2f200c4a457933dbd98d3cf4e911870877bd94d9656cc0fcb390681/cffi-1.17.1-cp310-cp310-win32.whl", hash = "sha256:c9c3d058ebabb74db66e431095118094d06abf53284d9c81f27300d0e0d8bc7c", size = 171804 },
    { url = "https://files.pythonhosted.org/packages/d1/b6/0b0f5ab93b0df4acc49cae758c81fe4e5ef26c3ae2e10cc69249dfd8b3ab/cffi-1.17.1-cp310-cp310-win_amd64.whl", hash = "sha256:0f048dcf80db46f0098ccac01132761580d28e28bc0f78ae0d58048063317e15", size = 181299 },
    { url = "https://files.pythonhosted.org/packages/34/33/e1b8a1ba29025adbdcda5fb3a36f94c03d771c1b7b12f726ff7fef2ebe36/cffi-1.17.1-cp311-cp311-win32.whl", hash = "sha256:85a950a4ac9c359340d5963966e3e0a94a676bd6245a4b55bc43949eee26a655", size = 171727 },
    { url = "https://files.pythonhosted.org/packages/3d/97/50228be003bb2802627d28ec0627837ac0bf35c90cf769812056f235b2d1/cffi-1.17.1-cp311-cp311-win_amd64.whl", hash = "sha256:caaf0640ef5f5517f49bc275eca1406b0ffa6aa184892812030f04c2abf589a0", size = 181400 },
    { url = "https://files.pythonhosted.org/packages/86/c5/28b2d6f799ec0bdecf44dced2ec5ed43e0eb63097b0f58c293583b406582/cffi-1.17.1-cp312-cp312-win32.whl", hash = "sha256:a08d7e755f8ed21095a310a693525137cfe756ce62d066e53f502a83dc550f65", size = 172448 },
    { url = "https://files.pythonhosted.org/packages/50/b9/db34c4755a7bd1cb2d1603ac3863f22bcecbd1ba29e5ee841a4bc510b294/cffi-1.17.1-cp312-cp312-win_amd64.whl", hash = "sha256:51392eae71afec0d0c8fb1a53b204dbb3bcabcb3c9b807eedf3e1e6ccf2de903", size = 181976 },
    { url = "https://files.pythonhosted.org/packages/bf/ee/f94057fa6426481d663b88637a9a10e859e492c73d0384514a17d78ee205/cffi-1.17.1-cp313-cp313-win32.whl", hash = "sha256:e03eab0a8677fa80d646b5ddece1cbeaf556c313dcfac435ba11f107ba117b5d", size = 172475 },
    { url = "https://files.pythonhosted.org/packages/7c/fc/6a8cb64e5f0324877d503c854da15d76c1e50eb722e320b15345c4d0c6de/cffi-1.17.1-cp313-cp313-win_amd64.whl", hash = "sha256:f6a16c31041f09ead72d69f583767292f750d24913dadacf5756b966aacb3f1a", size = 182009 },
    { url = "https://files.pythonhosted.org/packages/cb/b5/fd9f8b5a84010ca169ee49f4e4ad6f8c05f4e3545b72ee041dbbcb159882/cffi-1.17.1-cp39-cp39-win32.whl", hash = "sha256:e31ae45bc2e29f6b2abd0de1cc3b9d5205aa847cafaecb8af1476a609a2f6eb7", size = 171820 },
    { url = "https://files.pythonhosted.org/packages/8c/52/b08750ce0bce45c143e1b5d7357ee8c55341b52bdef4b0f081af1eb248c2/cffi-1.17.1-cp39-cp39-win_amd64.whl", hash = "sha256:d016c76bdd850f3c626af19b0542c9677ba156e4ee4fccfdd7848803533ef662", size = 181290 },
]

[[package]]
name = "encumbered-twitter"
version = "0.1.0"
source = { virtual = "." }
dependencies = [
    { name = "python-dotenv" },
    { name = "selenium" },
]

[package.metadata]
requires-dist = [
    { name = "python-dotenv", specifier = ">=1.0.1" },
    { name = "selenium", specifier = ">=4.25.0" },
]

[[package]]
name = "exceptiongroup"
version = "1.2.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/09/35/2495c4ac46b980e4ca1f6ad6db102322ef3ad2410b79fdde159a4b0f3b92/exceptiongroup-1.2.2.tar.gz", hash = "sha256:47c2edf7c6738fafb49fd34290706d1a1a2f4d1c6df275526b62cbb4aa5393cc", size = 28883 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/02/cc/b7e31358aac6ed1ef2bb790a9746ac2c69bcb3c8588b41616914eb106eaf/exceptiongroup-1.2.2-py3-none-any.whl", hash = "sha256:3111b9d131c238bec2f8f516e123e14ba243563fb135d3fe885990585aa7795b", size = 16453 },
]

[[package]]
name = "h11"
version = "0.14.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f5/38/3af3d3633a34a3316095b39c8e8fb4853a28a536e55d347bd8d8e9a14b03/h11-0.14.0.tar.gz", hash = "sha256:8f19fbbe99e72420ff35c00b27a34cb9937e902a8b810e2c88300c6f0a3b699d", size = 100418 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/95/04/ff642e65ad6b90db43e668d70ffb6736436c7ce41fcc549f4e9472234127/h11-0.14.0-py3-none-any.whl", hash = "sha256:e3fe4ac4b851c468cc8363d500db52c2ead036020723024a109d37346efaa761", size = 58259 },
]

[[package]]
name = "idna"
version = "3.10"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f1/70/7703c29685631f5a7590aa73f1f1d3fa9a380e654b86af429e0934a32f7d/idna-3.10.tar.gz", hash = "sha256:12f65c9b470abda6dc35cf8e63cc574b1c52b11df2c86030af0ac09b01b13ea9", size = 190490 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/76/c6/c88e154df9c4e1a2a66ccf0005a88dfb2650c1dffb6f5ce603dfbd452ce3/idna-3.10-py3-none-any.whl", hash = "sha256:946d195a0d259cbba61165e88e65941f16e9b36ea6ddb97f00452bae8b1287d3", size = 70442 },
]

[[package]]
name = "outcome"
version = "1.3.0.post0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "attrs" },
]
sdist = { url = "https://files.pythonhosted.org/packages/98/df/77698abfac98571e65ffeb0c1fba8ffd692ab8458d617a0eed7d9a8d38f2/outcome-1.3.0.post0.tar.gz", hash = "sha256:9dcf02e65f2971b80047b377468e72a268e15c0af3cf1238e6ff14f7f91143b8", size = 21060 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/55/8b/5ab7257531a5d830fc8000c476e63c935488d74609b50f9384a643ec0a62/outcome-1.3.0.post0-py2.py3-none-any.whl", hash = "sha256:e771c5ce06d1415e356078d3bdd68523f284b4ce5419828922b6871e65eda82b", size = 10692 },
]

[[package]]
name = "pycparser"
version = "2.22"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/1d/b2/31537cf4b1ca988837256c910a668b553fceb8f069bedc4b1c826024b52c/pycparser-2.22.tar.gz", hash = "sha256:491c8be9c040f5390f5bf44a5b07752bd07f56edf992381b05c701439eec10f6", size = 172736 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/13/a3/a812df4e2dd5696d1f351d58b8fe16a405b234ad2886a0dab9183fb78109/pycparser-2.22-py3-none-any.whl", hash = "sha256:c3702b6d3dd8c7abc1afa565d7e63d53a1d0bd86cdc24edd75470f4de499cfcc", size = 117552 },
]

[[package]]
name = "pysocks"
version = "1.7.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/bd/11/293dd436aea955d45fc4e8a35b6ae7270f5b8e00b53cf6c024c83b657a11/PySocks-1.7.1.tar.gz", hash = "sha256:3f8804571ebe159c380ac6de37643bb4685970655d3bba243530d6558b799aa0", size = 284429 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/8d/59/b4572118e098ac8e46e399a1dd0f2d85403ce8bbaad9ec79373ed6badaf9/PySocks-1.7.1-py3-none-any.whl", hash = "sha256:2725bd0a9925919b9b51739eea5f9e2bae91e83288108a9ad338b2e3a4435ee5", size = 16725 },
]

[[package]]
name = "python-dotenv"
version = "1.0.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/bc/57/e84d88dfe0aec03b7a2d4327012c1627ab5f03652216c63d49846d7a6c58/python-dotenv-1.0.1.tar.gz", hash = "sha256:e324ee90a023d808f1959c46bcbc04446a10ced277783dc6ee09987c37ec10ca", size = 39115 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/6a/3e/b68c118422ec867fa7ab88444e1274aa40681c606d59ac27de5a5588f082/python_dotenv-1.0.1-py3-none-any.whl", hash = "sha256:f7b63ef50f1b690dddf550d03497b66d609393b40b564ed0d674909a68ebf16a", size = 19863 },
]

[[package]]
name = "selenium"
version = "4.25.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "certifi" },
    { name = "trio" },
    { name = "trio-websocket" },
    { name = "typing-extensions" },
    { name = "urllib3", extra = ["socks"] },
    { name = "websocket-client" },
]
sdist = { url = "https://files.pythonhosted.org/packages/0e/5a/d3735b189b91715fd0f5a9b8d55e2605061309849470e96ab830f02cba40/selenium-4.25.0.tar.gz", hash = "sha256:95d08d3b82fb353f3c474895154516604c7f0e6a9a565ae6498ef36c9bac6921", size = 957765 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/aa/85/fa44f23dd5d5066a72f7c4304cce4b5ff9a6e7fd92431a48b2c63fbf63ec/selenium-4.25.0-py3-none-any.whl", hash = "sha256:3798d2d12b4a570bc5790163ba57fef10b2afee958bf1d80f2a3cf07c4141f33", size = 9693127 },
]

[[package]]
name = "sniffio"
version = "1.3.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/a2/87/a6771e1546d97e7e041b6ae58d80074f81b7d5121207425c964ddf5cfdbd/sniffio-1.3.1.tar.gz", hash = "sha256:f4324edc670a0f49750a81b895f35c3adb843cca46f0530f79fc1babb23789dc", size = 20372 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e9/44/75a9c9421471a6c4805dbf2356f7c181a29c1879239abab1ea2cc8f38b40/sniffio-1.3.1-py3-none-any.whl", hash = "sha256:2f6da418d1f1e0fddd844478f41680e794e6051915791a034ff65e5f100525a2", size = 10235 },
]

[[package]]
name = "sortedcontainers"
version = "2.4.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/e8/c4/ba2f8066cceb6f23394729afe52f3bf7adec04bf9ed2c820b39e19299111/sortedcontainers-2.4.0.tar.gz", hash = "sha256:25caa5a06cc30b6b83d11423433f65d1f9d76c4c6a0c90e3379eaa43b9bfdb88", size = 30594 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/32/46/9cb0e58b2deb7f82b84065f37f3bffeb12413f947f9388e4cac22c4621ce/sortedcontainers-2.4.0-py2.py3-none-any.whl", hash = "sha256:a163dcaede0f1c021485e957a39245190e74249897e2ae4b2aa38595db237ee0", size = 29575 },
]

[[package]]
name = "trio"
version = "0.27.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "attrs" },
    { name = "cffi", marker = "implementation_name != 'pypy' and os_name == 'nt'" },
    { name = "exceptiongroup", marker = "python_full_version < '3.11'" },
    { name = "idna" },
    { name = "outcome" },
    { name = "sniffio" },
    { name = "sortedcontainers" },
]
sdist = { url = "https://files.pythonhosted.org/packages/17/d1/a83dee5be404da7afe5a71783a33b8907bacb935a6dc8c69ab785e4a3eed/trio-0.27.0.tar.gz", hash = "sha256:1dcc95ab1726b2da054afea8fd761af74bad79bd52381b84eae408e983c76831", size = 568064 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/3c/83/ec3196c360afffbc5b342ead48d1eb7393dd74fa70bca75d33905a86f211/trio-0.27.0-py3-none-any.whl", hash = "sha256:68eabbcf8f457d925df62da780eff15ff5dc68fd6b367e2dde59f7aaf2a0b884", size = 481734 },
]

[[package]]
name = "trio-websocket"
version = "0.11.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "exceptiongroup", marker = "python_full_version < '3.11'" },
    { name = "trio" },
    { name = "wsproto" },
]
sdist = { url = "https://files.pythonhosted.org/packages/dd/36/abad2385853077424a11b818d9fd8350d249d9e31d583cb9c11cd4c85eda/trio-websocket-0.11.1.tar.gz", hash = "sha256:18c11793647703c158b1f6e62de638acada927344d534e3c7628eedcb746839f", size = 26511 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/48/be/a9ae5f50cad5b6f85bd2574c2c923730098530096e170c1ce7452394d7aa/trio_websocket-0.11.1-py3-none-any.whl", hash = "sha256:520d046b0d030cf970b8b2b2e00c4c2245b3807853ecd44214acd33d74581638", size = 17408 },
]

[[package]]
name = "typing-extensions"
version = "4.12.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/df/db/f35a00659bc03fec321ba8bce9420de607a1d37f8342eee1863174c69557/typing_extensions-4.12.2.tar.gz", hash = "sha256:1a7ead55c7e559dd4dee8856e3a88b41225abfe1ce8df57b7c13915fe121ffb8", size = 85321 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/26/9f/ad63fc0248c5379346306f8668cda6e2e2e9c95e01216d2b8ffd9ff037d0/typing_extensions-4.12.2-py3-none-any.whl", hash = "sha256:04e5ca0351e0f3f85c6853954072df659d0d13fac324d0072316b67d7794700d", size = 37438 },
]

[[package]]
name = "urllib3"
version = "2.2.3"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/ed/63/22ba4ebfe7430b76388e7cd448d5478814d3032121827c12a2cc287e2260/urllib3-2.2.3.tar.gz", hash = "sha256:e7d814a81dad81e6caf2ec9fdedb284ecc9c73076b62654547cc64ccdcae26e9", size = 300677 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/ce/d9/5f4c13cecde62396b0d3fe530a50ccea91e7dfc1ccf0e09c228841bb5ba8/urllib3-2.2.3-py3-none-any.whl", hash = "sha256:ca899ca043dcb1bafa3e262d73aa25c465bfb49e0bd9dd5d59f1d0acba2f8fac", size = 126338 },
]

[package.optional-dependencies]
socks = [
    { name = "pysocks" },
]

[[package]]
name = "websocket-client"
version = "1.8.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/e6/30/fba0d96b4b5fbf5948ed3f4681f7da2f9f64512e1d303f94b4cc174c24a5/websocket_client-1.8.0.tar.gz", hash = "sha256:3239df9f44da632f96012472805d40a23281a991027ce11d2f45a6f24ac4c3da", size = 54648 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/5a/84/44687a29792a70e111c5c477230a72c4b957d88d16141199bf9acb7537a3/websocket_client-1.8.0-py3-none-any.whl", hash = "sha256:17b44cc997f5c498e809b22cdf2d9c7a9e71c02c8cc2b6c56e7c2d1239bfa526", size = 58826 },
]

[[package]]
name = "wsproto"
version = "1.2.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "h11" },
]
sdist = { url = "https://files.pythonhosted.org/packages/c9/4a/44d3c295350d776427904d73c189e10aeae66d7f555bb2feee16d1e4ba5a/wsproto-1.2.0.tar.gz", hash = "sha256:ad565f26ecb92588a3e43bc3d96164de84cd9902482b130d0ddbaa9664a85065", size = 53425 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/78/58/e860788190eba3bcce367f74d29c4675466ce8dddfba85f7827588416f01/wsproto-1.2.0-py3-none-any.whl", hash = "sha256:b9acddd652b585d75b20477888c56642fdade28bdfd3579aa24a4d2c037dd736", size = 24226 },
]


-----------------------

/timerelease.sh:
-----------------------

#!/bin/bash

# Convert human-readable time to Unix timestamp
TIMEOUT_READABLE=$(date -d '+7 days')
timeout_unix=$(date -d "$TIMEOUT_READABLE" +%s)

# Public Ethereum JSON-RPC endpoint
ETH_NODE_URL="https://rpc.ankr.com/eth"

# Continuously check until the target time is reached
while true; do
    # Fetch the latest block's timestamp
    timestamp_hex=$(curl -s -X POST -H "Content-Type: application/json" --data '{"jsonrpc":"2.0","method":"eth_getBlockByNumber","params":["latest", true],"id":1}' $ETH_NODE_URL | jq -r '.result.timestamp')

    # Remove "0x" prefix and convert to decimal
    current_timestamp=$((16#${timestamp_hex#0x}))

    # Check if current Ethereum timestamp has reached the timeout
    if (( current_timestamp >= timeout_unix )); then
        echo "Time release triggered!"
	cat agent/mykey.hex
	echo TWITTER_PASSWORD $TWITTER_PASSWORD
	echo X_PASSWORD $X_PASSWORD
	echo X_AUTH_TOKENS $X_AUTH_TOKENS
	echo PROTONMAIL_PASSWORD $PROTONMAIL_PASSWORD
        break
    else
        echo "Not yet. Waiting until $TIMEOUT_READABLE (Current Ethereum time: $(date -d @$current_timestamp))"
    fi

    # Wait before checking again
    sleep 600
done